# effective-java
study effective java

## 第7章 ラムダとストリーム

### 項目42 無名クラスよりもラムダを選ぶ

- 単一の抽象メソッドを持つインターフェースは特別
  - 関数型インターフェース
- ラムダは無名クラスより簡潔に関数型インターフェイスのインスタンスを生成できる
- 型を宣言することで明瞭になるのでなければ、ラムダパラメータの型は省略する
  - 型宣言は型推論が効かないときに使う
- Comparatorの無名クラスはラムダで簡潔になる
  - コンパレータ構築メソッドで更に簡潔になる(`comparingInt(String::length)`)
  - Listインターフェースのsortメソッドを使えばさらに短くなる
    - Java8ではCollections.sortじゃなくてよさそう
- Enumの抽象メソッド(定数固有メソッド)をラムダのフィールドに書き換えることができる
  - 事前定義された関数型インターフェースが数多くある(`DoubleBinaryOperator`)
  - 複雑な場合は避ける
  - インスタンスメンバーにはアクセスできない
- ラムダは名前とドキュメントが欠けている
  - ラムダは一行が理想であり三行が妥当な最大
- 無名クラスにしかできないこと
  - 抽象クラスや複数メソッドを持つインターフェースのインスタンス作成
  - ラムダはthisが自身への参照ではない
- ラムダと無名クラスはシリアライズ/デシリアライズが不確実
  - シリアライズしたい関数オブジェクトはprivate staticなネストクラスにする

### 項目43 ラムダよりもメソッド参照を選ぶ

- メソッド参照はたいてい簡潔で明瞭になる
  - パラメータ名が有益なドキュメンテーションを提供するならラムダでもよい
  - ○ `map.merge(key, 1, Integer::sum);`
  - △ `map.merge(key, 1, (count, incr) -> count + incr);`
- ラムダでできないことでメソッド参照ができることはない
- ラムダが分かりづらいならメソッド参照に切り出す
- メソッドがラムダと同じクラスにある場合ラムダのほうが簡潔になる
- 5つの参照
  - static
    - `Integer::parseInt`
    - レシーバがstaticメソッドの引数になる
  - バウンド
    - `Instant.now()::isAfter`
    - レシーバがインスタンスメソッドの引数になる
  - アンバウンド
    - `String::toLowerCase`
    - レシーバのメソッドを呼び出す
  - クラスコンストラクタ
    - `TreeMap<K,V>::new`
  - 配列コンストラクタ
    - `int[]::new`

### 項目44 標準の関数型インターフェースを使う

- ラムダがあるので、Template Methodパターンはもはや魅力的ではない
  - 関数オブジェクトを受け取るファクトリかコンストラクタを作る
- 専用の関数型インターフェースではなく標準の関数型インターフェースを使う
- 6個の基本インターフェース
  - Operator
    - 引数を取り、引数の型と同じ型を返す
  - Predicate
    - 引数を取り、boolを返す
  - Function
    - 引数を取り、引数と異なる型を返す
  - Supplier
    - 引数を取らず、値を返す
  - Consumer
    - 引数を取り、値を返さない
- 基本インターフェースには変形がある
  - 基本データ型用変形
    - IntPredicate
    - LongToIntFunction
  - 引数を受け取る数の変形
    - BiFunction
- 基本データ型のインターフェースを使用してオートボクシングは使わない
- 独自の関数型インターフェースを作成するケース
  - 名前がドキュメンテーションになる
  - 関連付けられた強い契約を持っている
  - 有益なdefaultメソッドを提供できる
- @FunctionalInterface
  - ラムダを可能にすることを伝えるアノテーション
- 同じ引数の位置で異なる関数型を受け取るメソッドのオーバーロードをしない
  - クライアント側でキャストが必要になることがある

### 項目45 ストリームを注意して使う

- ストリームAPIが提供する抽象化
  - ストリーム
    - データ要素のシーケンス
  - ストリームパイプライン
    - データ要素に対する複数ステージの計算
- ストリームパイプライン
  - 中間操作と終端操作がある
  - 終端操作が呼び出されるまで評価されない
  - parallelにしなければ順次実行
    - parallelを使うのが適切な場合は滅多にない
- Map#computeIfAbsent
  - キーを探し、存在しなければ関数オブジェクトを適用する
  - 個々のキーに複数の値を関連付けるマップの実装が容易になる
- ラムダを乱用すると理解や保守が難しくなる
- 読みやすくするために
  - 終端操作を適宜利用する
  - ラムダのパラメータ名を丁寧に命名する
  - ヘルパーメソッドを使う
- char値を処理するためにストリームを使うのは控える
- すべてのループをストリームにすればよいというものではない
- コードブロックでできて関数オブジェクトでできないこと
  - ローカル変数の読み出しや書き出し
  - return, break, continue
  - 例外のスロー
- ストリームが適していること
  - 要素の均一な変換
  - 要素のフィルター
  - 要素を単一操作（加算、結合、最小値の計算、etc）でまとめる
  - 共通の属性で要素をグループ化
  - 条件に一致する要素の検索
- ストリームパイプラインの複数ステージは元の属性を失う
  - 両方の値を持つペアオブジェクトのマッピングは冗長になる
  - 結果から元の値を計算できるように逆マッピングするとよい
    - 🤪 よく分からなかった。。
- どちらがよいか決められない場合もある
  - ループが無難
  - 両方試してみてうまくいく方を選ぼう

### 項目46 ストリームで副作用のない関数を選ぶ

- ストリームの中間操作も終端操作も入力だけに依存させる
  - 純粋関数
  - 状態に依存させない
  - 副作用がない
- forEachはストリームの計算結果を報告するためだけに使う
　- 既存のコレクションに結果を追加するという目的には意味がある
- コレクターはストリームを使うために学ぶべき概念
- ストリームを本物のコレクションに集めるためのコレクター
  - toList, toSet, toCollection
- Mapへ集めるためのコレクター
  - toMap(keyMapper, valueMapper)
  - toMap(keyMapper, valueMapper, mergeFunction)
    - 同一Keyの場合のValueをmergeFunctionで生成する
  - toMap(keyMapper, valueMapper, mergeFunction, mapSupplier)
    - TreeMapやEnumMapといった特定の型を指定する
- グループ化してMapを生成するコレクタ
  - groupingBy(classifier)
    - 分類関数で要素が所属するカテゴリを返す
    - カテゴリがマップのKeyになる
    - ValueはList
  - groupingBy(classifier, downstream)
    - Valueをリスト以外にコレクトする
    - toSetを渡すのがもっとも単純
    - toCollectionを渡すと好きなコレクション型にできる
    - counting()を渡すとカテゴリ内の要素数をValueにできる
  - マップファクトリも指定可能
    - 🤔 マップ側の操作も合わせてできる？
  - groupingByConcurrent
    - 並列に動作する
  - partitioningBy
    - 分類関数の変わりに述語を受け取る
    - KeyがBooleanになる
- ダウンストリームコレクタ
  - counting
  - summing
  - averaging
  - summarizing
- コレクションに関係ないコレクタ
  - minBy
  - maxBy
  - joining
    - CharSequenceのストリームでのみ利用
- Collectorsのメンバーは可読性のためstaticインポートするのが慣習
- ストリームパイプラインのプログラミングの本質は副作用のない関数オブジェクト
- 最も重要なコレクターファクトリー
  - toSet
  - toMap
  - groupingBy
  - joining

## 第9章 プログラミング一般

### 項目57 ローカル変数のスコープを最小限にする

- ローカル変数は使用するときに宣言する
- 初期化子を含んでいるべきである
- ループ内でしか使用しないならwhileループよりforループを選ぶ
- メソッドを小さくして焦点をハッキリさせる
   - 一つの処理に対して一つのメソッドにする

### 項目58 従来のforループよりfor-eachループを選ぶ

- 処理によってはストリームで行うのが最善
- for-eachは優れている
  - イテレータ変数とインデックス変数を隠蔽
  - パフォーマンス上のペナルティもない
- for-eachループが使えないよくある状況
  - 破壊的フィルタリング
    - 要素を取り除きながらコレクションを走査するとき
    - Collection#removeIfでたいてい避けられる
  - 変換
    - 要素の一部や全部を置換する場合
    - 🤔 stream#mapでやればよさそうな
  - 並列イテレーション
    - 複数のコレクションを並列に走査する
    - 🤔 そうしなければならない理由がないなら避けたいところ
- for-eachループを使うだけなら Iterable インターフェースを実装すればOK
  - [参考](http://mindalign.sblo.jp/article/183499180.html)

### 項目59 ライブラリを知り、ライブラリを使う

- 標準ライブラリには書いた専門家と、使用した人々の経験が詰まっている
  - ライブラリーのコードは平均的開発者が専念できるよりもはるかに多くの配慮がなされる
  - 共通だと思えることをする場合、ライブラリーに既にないか調べる
- 基礎の配管よりは自分のアプリケーションに時間を費やす
- 標準ライブラリは時間と共に改善される（ことがある）
- 標準ライブラリを使ったコードは容易で保守しやすい
- RandomよりはThreadLocalRandomを使う
  - 並列ならSplittableRandom
- 主要リリースごとにライブラリに追加される機能を知っておく
- `java.lang` , `java.util` , `java.io` の内容を知っておくべき
- コレクションとストリームは基本的な道具
- 標準ライブラリが要求に答えられない場合、高品質のサードパーティーのライブラリを調べる
  - GoogleのGuava

### 項目60 正確な答えが必要ならば、floatとdoubleを避ける

- 正確な答えを必要とする計算にfloatやdoubleを使用しない
- とりわけ金銭計算には適していない
- BigDecimalかintかlongを使う
- 9桁を超えないならint、18桁を超えないならlong、それ以上ならBigDecimal
- 丸めが必要ならBigDecimal
  - ただしコストと不便さがある

### 項目61 ボクシングされた基本データより基本データ型を選ぶ

- 基本データと基本データ型の違い
  - 基本データは値しか持たないが、基本データ型はアイデンティティをインスタンスごとに持つ
  - 基本データ型はnull値を持つ
  - 基本データは一般に基本データ型より効率的
- ボクシングされた基本データ型に `==` 演算子を適用するのはほとんどの場合誤り
  - インスタンス比較になってしまう
- 基本データ型は初期値がnull
  - 自動アンボクシングでNullPointerExceptionが発生してしまう
- オートボクシング、アンボクシングが非効率を生み出す
- 選択できる場合には、基本データ型を選ぶ
- ボクシングされた基本データ型を使用すべき時とは
  - コレクション内の要素・キー・値
  - パラメータ化された型の型パラメータ
