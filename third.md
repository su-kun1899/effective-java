# effective-java
study effective java

## 第7章 ラムダとストリーム

### 項目42 無名クラスよりもラムダを選ぶ

- 単一の抽象メソッドを持つインターフェースは特別
  - 関数型インターフェース
- ラムダは無名クラスより簡潔に関数型インターフェイスのインスタンスを生成できる
- 型を宣言することで明瞭になるのでなければ、ラムダパラメータの型は省略する
  - 型宣言は型推論が効かないときに使う
- Comparatorの無名クラスはラムダで簡潔になる
  - コンパレータ構築メソッドで更に簡潔になる(`comparingInt(String::length)`)
  - Listインターフェースのsortメソッドを使えばさらに短くなる
    - Java8ではCollections.sortじゃなくてよさそう
- Enumの抽象メソッド(定数固有メソッド)をラムダのフィールドに書き換えることができる
  - 事前定義された関数型インターフェースが数多くある(`DoubleBinaryOperator`)
  - 複雑な場合は避ける
  - インスタンスメンバーにはアクセスできない
- ラムダは名前とドキュメントが欠けている
  - ラムダは一行が理想であり三行が妥当な最大
- 無名クラスにしかできないこと
  - 抽象クラスや複数メソッドを持つインターフェースのインスタンス作成
  - ラムダはthisが自身への参照ではない
- ラムダと無名クラスはシリアライズ/デシリアライズが不確実
  - シリアライズしたい関数オブジェクトはprivate staticなネストクラスにする

### 項目43 ラムダよりもメソッド参照を選ぶ

- メソッド参照はたいてい簡潔で明瞭になる
  - パラメータ名が有益なドキュメンテーションを提供するならラムダでもよい
  - ○ `map.merge(key, 1, Integer::sum);`
  - △ `map.merge(key, 1, (count, incr) -> count + incr);`
- ラムダでできないことでメソッド参照ができることはない
- ラムダが分かりづらいならメソッド参照に切り出す
- メソッドがラムダと同じクラスにある場合ラムダのほうが簡潔になる
- 5つの参照
  - static
    - `Integer::parseInt`
    - レシーバがstaticメソッドの引数になる
  - バウンド
    - `Instant.now()::isAfter`
    - レシーバがインスタンスメソッドの引数になる
  - アンバウンド
    - `String::toLowerCase`
    - レシーバのメソッドを呼び出す
  - クラスコンストラクタ
    - `TreeMap<K,V>::new`
  - 配列コンストラクタ
    - `int[]::new`

## 第9章 プログラミング一般

### 項目57 ローカル変数のスコープを最小限にする

- ローカル変数は使用するときに宣言する
- 初期化子を含んでいるべきである
- ループ内でしか使用しないならwhileループよりforループを選ぶ
- メソッドを小さくして焦点をハッキリさせる
   - 一つの処理に対して一つのメソッドにする

### 項目58 従来のforループよりfor-eachループを選ぶ

- 処理によってはストリームで行うのが最善
- for-eachは優れている
  - イテレータ変数とインデックス変数を隠蔽
  - パフォーマンス上のペナルティもない
- for-eachループが使えないよくある状況
  - 破壊的フィルタリング
    - 要素を取り除きながらコレクションを走査するとき
    - Collection#removeIfでたいてい避けられる
  - 変換
    - 要素の一部や全部を置換する場合
    - 🤔 stream#mapでやればよさそうな
  - 並列イテレーション
    - 複数のコレクションを並列に走査する
    - 🤔 そうしなければならない理由がないなら避けたいところ
- for-eachループを使うだけなら Iterable インターフェースを実装すればOK
  - [参考](http://mindalign.sblo.jp/article/183499180.html)
